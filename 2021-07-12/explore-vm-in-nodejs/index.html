<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content=blog,html,css,javascript,react,vue,nodejs><meta name=description content="zoubingwu 个人博客, zoubingwu's blog"><link href=/assets/images/favicon.ico rel=bookmark type=image/x-icon><link href=/assets/images/favicon.ico rel=icon type=image/x-icon><link href=/assets/images/favicon.ico rel="shortcut icon" type=image/x-icon><link rel=stylesheet href=/assets/css/main.css type=text/css><link rel=preload href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.6.0/style.css as=style><link rel=preload href=/assets/fonts/font-awesome.min.css as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.6.0/style.css><link rel=alternate type=application/rss+xml title="RSS Feed for zoubingwu's blog" href=/feed.xml><title>explore vm in nodejs | https://zoubingwu.com</title><meta property=og:title content="explore vm in nodejs | https://zoubingwu.com"><meta property=og:locale content=en_US><meta name=description content="build secure sandbox"><meta property=og:description content="build secure sandbox"><link rel=canonical href=https://zoubingwu.com/2021-07-12/explore-vm-in-nodejs><meta property=og:url content=https://zoubingwu.com/2021-07-12/explore-vm-in-nodejs><meta property=og:site_name content="zoubingwu's blog"><meta property=og:type content=article><meta property=article:published_time content=2021-07-12T12:12:33.000Z><meta name=twitter:card content=summary><meta property=twitter:title content="explore vm in nodejs | https://zoubingwu.com"><script defer=defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "76b8468271b24f3180af2110f74841c3"}'></script></head><body><main class=content-container><div class=post><div class=post-title>explore vm in nodejs</div><span class=post-date><time>12 Jul 2021</time></span><div class=post-tag><ul><li><a><span><i class="fa fa-paperclip" aria-hidden=true></i>nodejs</span></a></li></ul></div><p>It&#39;s been a while.</p><p>最近看到 <a href=https://github.com/YMFE/yapi>YAPI</a> 项目因为沙盒执行脚本引起的安全问题。截止目前问题已经修复了，发布了一个 1.9.3 版本，<a href=https://github.com/YMFE/yapi/issues/2254>不过 tag 还打错了</a>。</p><p>去翻了一下代码，是一个典型的沙盒逃逸问题引起的，感觉有点哭笑不得。</p><p>切到 v1.9.2 版本，<code>~/server/middleware/mockServer.js</code> <a href=https://github.com/YMFE/yapi/blob/ff13353e2fd6e2c37908427dd2e6d287ef8d28ec/server/middleware/mockServer.js#L331>有一段执行 mock 脚本的逻辑</a>。</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">let</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">script</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">project</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">project_mock_script</span><span style="color: #ABB2BF">;</span></span>
<span class=line><span style="color: #E5C07B">yapi</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">commons</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">handleMockScript</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">context</span><span style="color: #ABB2BF">);</span></span></code></pre>
</code></pre><p>调用了 <code>~/server/utils/common.js</code> 中的 <code>handleMockScript</code> 函数，然后这个函数调用了 <code>sandbox</code> 函数，然后在 node 环境中会使用 <code>sandboxByNode</code> 函数来执行脚本，这个函数长这样：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">sandboxByNode</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">sandbox</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {}, </span><span style="color: #E06C75; font-style: italic">script</span><span style="color: #ABB2BF">) {</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">require</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;vm&#39;</span><span style="color: #ABB2BF">);</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #E06C75">script</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">Script</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF">);</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">context</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">createContext</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">sandbox</span><span style="color: #ABB2BF">);</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">script</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">runInContext</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">context</span><span style="color: #ABB2BF">, {</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #E06C75">timeout</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">10000</span></span>
<span class=line><span style="color: #ABB2BF">  });</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">sandbox</span><span style="color: #ABB2BF">;</span></span>
<span class=line><span style="color: #ABB2BF">}</span></span></code></pre>
</code></pre><p>这个漏洞怎么使用呢，很简单，一些 issue 里面也描述的很清楚了，由于 js 语言本身的特性，当你的 context 里暴露了对象或者函数的时候，其实你也把他们的 constructor 暴露出去了，基于原型链的访问，同时也暴露了沙盒本身的 constructor。</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">require</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;vm&#39;</span><span style="color: #ABB2BF">);</span></span>
<span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sandbox</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> { </span><span style="color: #E06C75">someNonPrimitive</span><span style="color: #ABB2BF">: {} };</span></span>
<span class=line></span>
<span class=line><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">createContext</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">sandbox</span><span style="color: #ABB2BF">);</span></span>
<span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">code</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`</span></span>
<span class=line><span style="color: #98C379">  this.someNonPrimitive.constructor.constructor(&#39;return process&#39;)().env;</span></span>
<span class=line><span style="color: #98C379">`</span><span style="color: #ABB2BF">;</span></span>
<span class=line></span>
<span class=line><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">log</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">runInContext</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">code</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">sandbox</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">USER</span><span style="color: #ABB2BF">) </span><span style="color: #7F848E; font-style: italic">// User name</span></span></code></pre>
</code></pre><p>首先得介绍一下 nodejs 中的 <code>vm</code> 模块。</p><p>官方文档实际上描述的也很清楚了：</p><blockquote><p>The vm module enables compiling and running code within V8 Virtual Machine contexts. <strong>The vm module is not a security mechanism. Do not use it to run untrusted code.</strong></p></blockquote><p>它的使用方式非常简单:</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">require</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;vm&#39;</span><span style="color: #ABB2BF">)</span></span>
<span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">code</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`console.log(&#39;hello from the vm&#39;)`</span></span>
<span class=line><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">runInThisContext</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">code</span><span style="color: #ABB2BF">) </span><span style="color: #7F848E; font-style: italic">// hello from the vm</span></span></code></pre>
</code></pre><p>vm 上除了有 <code>runInThisContext</code> 方法以外，还有 <code>runInNewContext</code>, <code>runInContext</code>方法，他们都是什么东西呢？</p><p>前端八股文里有一个被问得非常多的概念，那就是 js 中的执行上下文 （<code>execution context</code>），<code>this</code> 关键字实际上指向了当前代码的执行上下文，其中的坑也非常多。关于它的解释，可以<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this>查看相关的 MDN 文档</a>，我就不当二手贩子了。</p><p>回头看看前面的代码，当我们调用了 <code>console.log</code> 的时候发生了什么呢？我们从来没有定义过 <code>console</code> 这个对象，它实际上是由 runtime 内置的，并且注入到了 global context，因此我们可以在任何地方直接使用它，不需要额外的引入和定义，这个 global context，在浏览器中叫 <code>window</code>，在 node 环境中，则叫做 <code>global</code>（顺带一提为了解决不同 runtime 下不同名字的问题有一个已经 stage 4 的 <code>globalThis</code> 语法），命令行中进入 node 的 repl 环境，然后输入<code>this === global</code>，你就能看到它返回了 true，输入 <code>global.console</code> 就能看到它返回了 <code>console</code> 对象的定义和上面的所有方法。</p><p>那么答案就很明显了，<code>runInThisContext</code> 就是在当前的上下文中执行代码，因此它自然就可以访问到 <code>console</code> 了。</p><p>我们知道可以通过 bind，call，apply 这样的方式来修改上下文，类似的，我们也可以显示的设定代码执行的上下文：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">require</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;vm&#39;</span><span style="color: #ABB2BF">)</span></span>
<span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">context</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {}</span></span>
<span class=line><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">createContext</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">context</span><span style="color: #ABB2BF">)</span></span>
<span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">code</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`console.log(&#39;hello world&#39;)`</span></span>
<span class=line><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">runInContext</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">code</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">context</span><span style="color: #ABB2BF">)</span></span></code></pre>
</code></pre><p>这一次我们指定了一个空对象作为上下文，再次执行代码，你可以发现什么输出都没有了。</p><p>但是还记得我们可以通过 this 关键字来访问上下文对象吗？我们只要简单的修改一下代码，就还是能打印出 hello world：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">context</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {}</span></span>
<span class=line><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">createContext</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">context</span><span style="color: #ABB2BF">)</span></span>
<span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">code</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`this.constructor.constructor(&#39;console.log(&quot;hello world&quot;)&#39;)()`</span></span>
<span class=line><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">runInContext</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">code</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">context</span><span style="color: #ABB2BF">)</span></span></code></pre>
</code></pre><p>我们能访问 global context 下的 console，那么意味着也可以访问 process 对象等各种模块，执行任意我们想要执行的代码，而这就违背了我们最初的意愿。</p><p>但业务上，我们有时候会确实存在执行一些外部输入的动态脚本的需求，典型的像 leetcode 的场景，或者一些用户自定义插件，让用户在可控的范围内，去扩展更多的能力，来满足更多的需求。</p><p>如果只是单纯的执行动态脚本，我们有非常多的选择，比如臭名昭著的 <code>eval</code>，或者 <code>Function</code>。</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #56B6C2">eval</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;1 + 1&#39;</span><span style="color: #ABB2BF">) </span><span style="color: #7F848E; font-style: italic">// 2</span></span>
<span class=line></span>
<span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sum</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Function</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;m&#39;</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">&#39;n&#39;</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">&#39;return m + n&#39;</span><span style="color: #ABB2BF">);</span></span>
<span class=line><span style="color: #61AFEF">sum</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span><span style="color: #7F848E; font-style: italic">// 2</span></span></code></pre>
</code></pre><p>或者我们可以创建一个 iframe 或者 worker，让代码在单独的环境中运行，对于不受自己控制的环境，<a href=https://zhuanlan.zhihu.com/p/34191831>甚至你可以自己实现一个 js 解释器</a>。</p><p>同单纯客户端的应用不同，如果在服务端需要有这样的能力，就需要考虑非常多的安全问题，外部输入的脚本必须受到严格的限制和隔离，不能影响到宿主程序，更不能影响到其他用户。</p><p>社区基于 vm 模块也给出了很多的解决方案，其中做的比较好的，就是 <a href=https://www.npmjs.com/package/vm2><code>vm2</code></a> 了。</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> { </span><span style="color: #E5C07B">VM</span><span style="color: #ABB2BF"> } </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">require</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">&#39;vm2&#39;</span><span style="color: #ABB2BF">);</span></span>
<span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">VM</span><span style="color: #ABB2BF">();</span></span>
<span class=line></span>
<span class=line><span style="color: #E5C07B">vm</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">run</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">`process.exit()`</span><span style="color: #ABB2BF">); </span><span style="color: #7F848E; font-style: italic">// TypeError: process.exit is not a function</span></span></code></pre>
</code></pre><p><code>vm2</code> 会使用 <code>proxy</code> 作为防御，阻止所有对 <code>constructor</code> 和 <code>__proto__</code> 等属性的访问，同时通过白名单机制来限制对 node 内置模块的访问。</p><p>当然，并不是使用了 <code>vm2</code> 就可以高枕无忧了，我们还需要考虑很多其他的可能性。假如：</p><ol><li>假如我们编写的沙盒代码有 bug 怎么办？</li><li>假如我们白名单的模块中包含危险的依赖暴露出去了怎么办？</li><li>假如 <code>vm2</code> 本身有 bug 怎么办？它也确实出过 bug</li><li>假如 node 本身有问题怎么办？</li><li>假如 node 的一些相关依赖有问题怎么办？</li></ol><p>目前还没有完美的解决方案，这个世界不存在绝对安全，只存在相对安全，我们可以采取一些措施，来尽可能的减少可能存在的风险。</p><p>比如将 <code>vm2</code> 和相关的沙盒逻辑隔离在独立的进程中运行，将程序运行在 docker 这样的环境中而不是直接在宿主机器上运行，针对沙盒进程进行 CPU 内存的的配额限制，限制文件读写的能力等等。</p><p>例如 Google 推出了 <a href=https://github.com/google/gvisor>gVisor</a> 来尝试解决这些问题。</p><blockquote><p>Containers are not a sandbox. While containers have revolutionized how we develop, package, and deploy applications, using them to run untrusted or potentially malicious code without additional isolation is not a good idea. While using a single, shared kernel allows for efficiency and performance gains, it also means that container escape is possible with a single vulnerability.</p></blockquote><p>ref:</p><ul><li><a href=https://nodejs.org/api/vm.html>https://nodejs.org/api/vm.html</a></li><li><a href=https://medium.com/@devnullnor/a-secure-node-sandbox-f23b9fc9f2b0>https://medium.com/@devnullnor/a-secure-node-sandbox-f23b9fc9f2b0</a></li><li><a href=https://github.com/google/gvisor>https://github.com/google/gvisor</a></li><li><a href=https://github.com/Houfeng/safeify/blob/master/DOC.md>https://github.com/Houfeng/safeify/blob/master/DOC.md</a></li><li><a href=https://github.com/YMFE/yapi/issues/2099>https://github.com/YMFE/yapi/issues/2099</a></li></ul></div><div class=footer><hr><div class=footer-link><a href=/archive aria-label="Read more about all archives"><i class="fa fa-archive" aria-hidden=true></i> </a><a target=_blank href=https://twitter.com/chow_won aria-label="Read more on twitter"><i class="fa fa-twitter" aria-hidden=true></i></a> <a target=_blank href=https://github.com/zoubingwu aria-label="Read more on github"><i class="fa fa-github" aria-hidden=true></i> </a><a target=_blank href=mailto:zoubingwu@gmail.com aria-label=Email><i class="fa fa-envelope" aria-hidden=true></i></a></div>© 2016-2023 zoubingwu. All rights reserved.</div></main></body></html>