<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta name=keywords content=blog,html,css,javascript,react,vue,nodejs><meta name=description content="zoubingwu 个人博客, zoubingwu's blog"><link href=/assets/images/favicon.ico rel=bookmark type=image/x-icon><link href=/assets/images/favicon.ico rel=icon type=image/x-icon><link href=/assets/images/favicon.ico rel="shortcut icon" type=image/x-icon><link rel=stylesheet href=/assets/css/main.css type=text/css><link rel=preload href=/assets/fonts/googlefont.css as=style><link rel=preload href=https://cdn.bootcdn.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css as=style><link rel=stylesheet href=/assets/fonts/googlefont.css as=style><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css as=style><link rel=alternate type=application/rss+xml title="RSS Feed for zoubingwu's blog" href=/feed.xml><title>Dependency Injectection pattern | https://zoubingwu.com</title><meta property=og:title content="Dependency Injectection pattern | https://zoubingwu.com"><meta property=og:locale content=en_US><meta name=description content="Dependency injection is an important application design pattern. It's used so widely that almost everyone just calls it DI."><meta property=og:description content="Dependency injection is an important application design pattern. It's used so widely that almost everyone just calls it DI."><link rel=canonical href=https://zoubingwu.com/2018-05-08/dependency-injectection-pattern><meta property=og:url content=https://zoubingwu.com/2018-05-08/dependency-injectection-pattern><meta property=og:site_name content="zoubingwu's blog"><meta property=og:type content=article><meta property=article:published_time content=2018-05-08T22:19:31.000Z><meta name=twitter:card content=summary><meta property=twitter:title content="Dependency Injectection pattern | https://zoubingwu.com"><script>(function (i, s, o, g, r, a, m) { i['GoogleAnalyticsObject'] = r; (i[r] = i[r]
  || function () { (i[r].q = i[r].q || []).push(arguments); }), (i[r].l = 1 *
  new Date()); (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
  a.async = 1; a.src = g; m.parentNode.insertBefore(a, m); })( window, document,
  'script', 'https://www.google-analytics.com/analytics.js', 'ga' );
  ga('create', 'UA-100363260-1', 'auto'); ga('send', 'pageview');</script></head><body><div class=content-container><div class=post><div class=post-title>Dependency Injectection pattern</div><span class=post-date><time>8 May 2018</time></span><div class=post-tag><ul><li><a><span><i class="fa fa-paperclip" aria-hidden=true></i>patterns</span></a></li></ul></div><p>依赖注入模式是应用开发中一种广泛使用的设计模式，要弄清楚为什么依赖注入模式很重要，我们可以直接来看看下面的例子。</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">export</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Car</span><span style="color: #ABB2BF"> {</span></span>
<span class=line></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">engine</span><span style="color: #ABB2BF">: </span><span style="color: #E5C07B">Engine</span><span style="color: #ABB2BF">;</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">tires</span><span style="color: #ABB2BF">: </span><span style="color: #E5C07B">Tires</span><span style="color: #ABB2BF">;</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">description</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&#39;No DI&#39;</span><span style="color: #ABB2BF">;</span></span>
<span class=line></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #C678DD">constructor</span><span style="color: #ABB2BF">() {</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">this</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">engine</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Engine</span><span style="color: #ABB2BF">();</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">this</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">tires</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Tires</span><span style="color: #ABB2BF">();</span></span>
<span class=line><span style="color: #ABB2BF">  }</span></span>
<span class=line></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #61AFEF">drive</span><span style="color: #ABB2BF">() {</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`</span><span style="color: #C678DD">${</span><span style="color: #E5C07B">this</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">description</span><span style="color: #C678DD">}</span><span style="color: #98C379"> car with `</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span></span>
<span class=line><span style="color: #ABB2BF">      </span><span style="color: #98C379">`</span><span style="color: #C678DD">${</span><span style="color: #E5C07B">this</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">engine</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">cylinders</span><span style="color: #C678DD">}</span><span style="color: #98C379"> cylinders and </span><span style="color: #C678DD">${</span><span style="color: #E5C07B">this</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">tires</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">make</span><span style="color: #C678DD">}</span><span style="color: #98C379"> tires.`</span><span style="color: #ABB2BF">;</span></span>
<span class=line><span style="color: #ABB2BF">  }</span></span>
<span class=line><span style="color: #ABB2BF">}</span></span></code></pre>
</code></pre><p>我们在汽车这个类的构造函数里直接创建一个新的引擎和轮胎的实例，初看上去这样的代码是 ok 的，但是当引擎或者轮胎这两个类出现改动时，这样的代码维护性就有问题了。</p><p>当修改了 Engine 这个 class，例如创建实例时需要额外的参数，那么同样需要修改 Car 这个 class 内部的代码，并且每当 new 一个新的 Car 时，他们都会有自己的独立的固定的 Engine 实例，使得代码非常的不灵活。</p><p>换句话说，Car class 依赖着 Engine 和 Tires 这两个类，但这两个类都是内部写死的，外部没有任何办法能接触到，这一点对代码的灵活性，健壮性都提出了挑战，同时也不方便编写测试代码。</p><p>我们怎么改动比较好一点呢？也很简单，直接使用参数来将依赖传入就可以了：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #61AFEF">constructor</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">public</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">engine</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">Engine</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">public</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">tires</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">Tires</span><span style="color: #ABB2BF">) { }</span></span>
<span class=line></span></code></pre>
</code></pre><p>使用的时候就可以直接：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">let</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">car</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Car</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Engine</span><span style="color: #ABB2BF">(), </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Tires</span><span style="color: #ABB2BF">());</span></span>
<span class=line></span></code></pre>
</code></pre><p>这样 Engine 和 Tires 都从 Car 中解耦出来，针对 Car 的测试时，我们也可以传入任何需要 mock 的依赖进去：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">MockEngine</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">extends</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Engine</span><span style="color: #ABB2BF"> { </span><span style="color: #E06C75">cylinders</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">8</span><span style="color: #ABB2BF">; }</span></span>
<span class=line><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">MockTires</span><span style="color: #ABB2BF">  </span><span style="color: #C678DD">extends</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Tires</span><span style="color: #ABB2BF">  { </span><span style="color: #E06C75">make</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&#39;YokoGoodStone&#39;</span><span style="color: #ABB2BF">; }</span></span>
<span class=line></span>
<span class=line><span style="color: #7F848E; font-style: italic">// Test car with 8 cylinders and YokoGoodStone tires.</span></span>
<span class=line><span style="color: #C678DD">let</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">car</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Car</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">MockEngine</span><span style="color: #ABB2BF">(), </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">MockTires</span><span style="color: #ABB2BF">());</span></span></code></pre>
</code></pre><p>这就是最基本的依赖注入模式，其实概念非常简单，依赖由外部注入，而非自己内部创建。</p><p>ref:</p><p><a href=https://angular.io/guide/dependency-injection-pattern>https://angular.io/guide/dependency-injection-pattern</a></p></div><div class=footer><hr><div class=footer-link><a href=/archive><i class="fa fa-archive" aria-hidden=true></i></a><a target=_blank href=https://twitter.com/chow_won><i class="fa fa-twitter" aria-hidden=true></i></a> <a target=_blank href=https://github.com/zoubingwu><i class="fa fa-github" aria-hidden=true></i></a> <a target=_blank href=mailto:zoubingwu@gmail.com><i class="fa fa-envelope" aria-hidden=true></i></a></div>© 2016-2021 zoubingwu. All rights reserved.</div></div></body></html>