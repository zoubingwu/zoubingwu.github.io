<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no"><meta name=keywords content=blog,html,css,javascript,react,vue,nodejs><meta name=description content="zoubingwu 个人博客, zoubingwu's blog"><link href=/assets/images/favicon.ico rel=bookmark type=image/x-icon><link href=/assets/images/favicon.ico rel=icon type=image/x-icon><link href=/assets/images/favicon.ico rel="shortcut icon" type=image/x-icon><link rel=stylesheet href=/assets/css/main.css type=text/css><link rel=preload href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.6.0/style.css as=style><link rel=preload href=https://cdn.bootcdn.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css as=style><link rel=stylesheet href=https://cdn.bootcdn.net/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css as=style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.6.0/style.css><link rel=alternate type=application/rss+xml title="RSS Feed for zoubingwu's blog" href=/feed.xml><title>Redux Optimization | https://zoubingwu.com</title><meta property=og:title content="Redux Optimization | https://zoubingwu.com"><meta property=og:locale content=en_US><meta name=description content="A short guide about how to optimize react/redux application."><meta property=og:description content="A short guide about how to optimize react/redux application."><link rel=canonical href=https://zoubingwu.com/2018-01-20/redux-optimization><meta property=og:url content=https://zoubingwu.com/2018-01-20/redux-optimization><meta property=og:site_name content="zoubingwu's blog"><meta property=og:type content=article><meta property=article:published_time content=2018-01-20T10:32:22.000Z><meta name=twitter:card content=summary><meta property=twitter:title content="Redux Optimization | https://zoubingwu.com"><script defer=defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "76b8468271b24f3180af2110f74841c3"}'></script></head><body><div class=content-container><div class=post><div class=post-title>Redux Optimization</div><span class=post-date><time>20 Jan 2018</time></span><div class=post-tag><ul><li><a><span><i class="fa fa-paperclip" aria-hidden=true></i>react</span></a></li><li><a><span><i class="fa fa-paperclip" aria-hidden=true></i>redux</span></a></li></ul></div><h2 id=前言>前言</h2><p>经常有人会觉得，使用 react/redux 的 web 应用性能会很差。大多数的情况下，这种性能的问题都来源于不必要的重复渲染，因为 DOM 的更新代价是十分昂贵的。</p><p>实际上在开发时，尤其是刚接触 React/redux 应用开发时，非常容易犯一些错误而引起这种重复的渲染。</p><h2 id=quick-dive-into-react-redux>quick dive into react-redux</h2><p>我们通常会使用 <code>connect</code> 这个高阶组件来使 React 组件订阅 redux store 中的变化，来更新这一组件和它的子组件。在 <code>react-redux</code> 中，已经对 <code>connect</code> 做了一定的优化，它的完整签名应该是这样子的：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">connect</span><span style="color: #ABB2BF">(</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #E06C75; font-style: italic">mapStateToProps</span><span style="color: #ABB2BF">,</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #E06C75; font-style: italic">mapDispatchToProps</span><span style="color: #ABB2BF">,</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #E06C75; font-style: italic">mergeProps</span><span style="color: #ABB2BF">,</span></span>
<span class=line><span style="color: #ABB2BF">  {</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">pure</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">,</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">areStatesEqual</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">strictEqual</span><span style="color: #ABB2BF">,</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">areOwnPropsEqual</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">shallowEqual</span><span style="color: #ABB2BF">,</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">areStatePropsEqual</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">shallowEqual</span><span style="color: #ABB2BF">,</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #E06C75; font-style: italic">areMergedPropsEqual</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">shallowEqual</span><span style="color: #ABB2BF">,</span></span>
<span class=line><span style="color: #ABB2BF">    ...</span><span style="color: #E06C75; font-style: italic">extraOptions</span></span>
<span class=line><span style="color: #ABB2BF">  } </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {}</span></span>
<span class=line><span style="color: #ABB2BF">) {</span></span>
<span class=line><span style="color: #ABB2BF">  ...</span></span>
<span class=line><span style="color: #ABB2BF">}</span></span></code></pre>
</code></pre><p>在我们的实际使用中，大多数情况下我们都只会传入前两个参数，但通过这个签名我们可以更好的理解它内部的逻辑。</p><p>所有通过 <code>connect</code> 传入的参数，都是用来生成一个对象，然后传入被包裹的组件来作为 props。</p><p><code>mapStateToProps</code> 是用来从 redux store 中抽取需要的状态数据来生成一个新的对象； 而 <code>mapDispatchToProps</code> 用来生成一个带有函数的对象，通常这些函数都是用来生成 action 的； 默认情况下 <code>mergeProps</code> 则把前两个参数生成的 <code>stateProps</code>, <code>dispatchProps</code> 和组件自己的 <code>ownProps</code> 来组合成一个 object，如果你传入了一个函数作为这个参数，那么则会按照你传入的这个函数来组合； 最后这一个参数，类似 <code>shouldComponentUpdate</code> 一样，可以按照你指定的选项来确定是否应该 re-render 组件，默认的情况会当作 pureComponent 一样处理。</p><p>那什么叫 pure 呢？其实翻一下 react 的文档就可以看到，pureComponent 同普通 react component 的区别就在于默认就引入了 <code>shouldComponentUpdate</code> 来进行 shallowEqual 比较 props 和 state。</p><p>所谓的 shallow，就是只是循环比较 object 的每个属性，执行<a href=http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero>samevaluezero</a>判断，但对于属性内更深的层次，则不会去比较了。例如我们可以看看 lodash 中的 <code>_.eq</code> 和 <code>_.isEqual</code>：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">object</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">: {</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #E06C75">b</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">1</span></span>
<span class=line><span style="color: #ABB2BF">  }</span></span>
<span class=line><span style="color: #ABB2BF">}</span></span>
<span class=line></span>
<span class=line><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">other</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {</span></span>
<span class=line><span style="color: #ABB2BF">  </span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">: {</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #E06C75">b</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">1</span></span>
<span class=line><span style="color: #ABB2BF">  }</span></span>
<span class=line><span style="color: #ABB2BF">}</span></span>
<span class=line></span>
<span class=line><span style="color: #E5C07B">_</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">eq</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">object</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">other</span><span style="color: #ABB2BF">) </span><span style="color: #7F848E; font-style: italic">// false， 虽然这两个对象看上去相同，但他们的 a 属性是不同的引用，指向了不同的 { b: 1 }</span></span>
<span class=line><span style="color: #E5C07B">_</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">isEqual</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">object</span><span style="color: #ABB2BF">. </span><span style="color: #E06C75">other</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic">// true</span></span></code></pre>
</code></pre><p><strong>因此我们可以得出一个非常重要的结论，那就是只传递给你的组件它需要的数据，否则多传入的冗余的数据的变化，也会引起组件的 re-render，这就造成了性能的浪费。</strong></p><p>依据这一个结论，我们就可以推导出一些基本的原则。</p><h3 id=分割-connected-的组件>分割 connected 的组件</h3><p>我们有时候会看到这种情况，使用一个大的 container 组件来获取所有的状态，然后通过 props 分发给内部的子组件：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">BigComponent</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> ({ </span><span style="color: #E06C75; font-style: italic">a</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">b</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">c</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">d</span><span style="color: #ABB2BF"> }) </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> (</span></span>
<span class=line><span style="color: #ABB2BF">  &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span>
<span class=line><span style="color: #ABB2BF">    &lt;</span><span style="color: #E5C07B">ComponentA</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66; font-style: italic">a</span><span style="color: #56B6C2">=</span><span style="color: #C678DD">{</span><span style="color: #E06C75">a</span><span style="color: #C678DD">}</span><span style="color: #ABB2BF">/&gt;</span></span>
<span class=line><span style="color: #ABB2BF">    &lt;</span><span style="color: #E5C07B">ComponentB</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66; font-style: italic">b</span><span style="color: #56B6C2">=</span><span style="color: #C678DD">{</span><span style="color: #E06C75">b</span><span style="color: #C678DD">}</span><span style="color: #ABB2BF">/&gt;</span></span>
<span class=line><span style="color: #ABB2BF">    &lt;</span><span style="color: #E5C07B">ComponentC</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66; font-style: italic">c</span><span style="color: #56B6C2">=</span><span style="color: #C678DD">{</span><span style="color: #E06C75">c</span><span style="color: #C678DD">}</span><span style="color: #ABB2BF">/&gt;</span></span>
<span class=line><span style="color: #ABB2BF">  &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span>
<span class=line><span style="color: #ABB2BF">)</span></span>
<span class=line></span>
<span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">connectedBigComponent</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">connect</span><span style="color: #ABB2BF">(</span></span>
<span class=line><span style="color: #ABB2BF">  ({ </span><span style="color: #E06C75; font-style: italic">a</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">b</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">c</span><span style="color: #ABB2BF"> }) </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> ({ </span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">b</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">c</span><span style="color: #ABB2BF"> })</span></span>
<span class=line><span style="color: #ABB2BF">)(</span><span style="color: #E06C75">BigComponent</span><span style="color: #ABB2BF">)</span></span></code></pre>
</code></pre><p>现在，只要是 a，b，c 状态中的任何一个改变，那么整个 <code>BigComponent</code>，包括其中的三个子组件，都会 re-render。然而实际上，我们只需要 a 状态改变时，CompopnentA 重新渲染就可以了，b，c 的改变，对它不应该有任何影响。</p><h3 id=将状态转化为尽可能的小和简单>将状态转化为尽可能的小和简单</h3><p>举个例子，我们有一个很大的列表，比如好几百个：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">List</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75; font-style: italic">props</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> (</span></span>
<span class=line><span style="color: #ABB2BF">  &lt;</span><span style="color: #E06C75">ul</span><span style="color: #ABB2BF">&gt;</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #C678DD">{</span></span>
<span class=line><span style="color: #ABB2BF">      </span><span style="color: #E5C07B">props</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">map</span><span style="color: #ABB2BF">(({ </span><span style="color: #E06C75; font-style: italic">content</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">itemId</span><span style="color: #ABB2BF"> }) </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> (</span></span>
<span class=line><span style="color: #ABB2BF">        &lt;</span><span style="color: #E5C07B">ListItem</span></span>
<span class=line><span style="color: #ABB2BF">          </span><span style="color: #D19A66; font-style: italic">onClick</span><span style="color: #56B6C2">=</span><span style="color: #C678DD">{</span><span style="color: #E06C75">onSelectItem</span><span style="color: #C678DD">}</span></span>
<span class=line><span style="color: #ABB2BF">          </span><span style="color: #D19A66; font-style: italic">content</span><span style="color: #56B6C2">=</span><span style="color: #C678DD">{</span><span style="color: #E06C75">content</span><span style="color: #C678DD">}</span></span>
<span class=line><span style="color: #ABB2BF">          </span><span style="color: #D19A66; font-style: italic">itemId</span><span style="color: #56B6C2">=</span><span style="color: #C678DD">{</span><span style="color: #E06C75">itemId</span><span style="color: #C678DD">}</span></span>
<span class=line><span style="color: #ABB2BF">          </span><span style="color: #D19A66; font-style: italic">key</span><span style="color: #56B6C2">=</span><span style="color: #C678DD">{</span><span style="color: #E06C75">itemId</span><span style="color: #C678DD">}</span></span>
<span class=line><span style="color: #ABB2BF">        /&gt;</span></span>
<span class=line><span style="color: #ABB2BF">      ))</span></span>
<span class=line><span style="color: #ABB2BF">    </span><span style="color: #C678DD">}</span></span>
<span class=line><span style="color: #ABB2BF">  &lt;/</span><span style="color: #E06C75">ul</span><span style="color: #ABB2BF">&gt;</span></span>
<span class=line><span style="color: #ABB2BF">)</span></span></code></pre>
</code></pre><p>当我们点击其中一个的时候，会发起一个 action 到 store 来更新当前选中是哪一个 - <code>selectedItem</code>，每一个 ListItem 会 connect 到 store 来获取这个 <code>selectedItem</code>：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ListItem</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">connect</span><span style="color: #ABB2BF">(</span></span>
<span class=line><span style="color: #ABB2BF">  ({ </span><span style="color: #E06C75; font-style: italic">selectedItem</span><span style="color: #ABB2BF"> }) </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> ({ </span><span style="color: #E06C75">selectedItem</span><span style="color: #ABB2BF"> })</span></span>
<span class=line><span style="color: #ABB2BF">)(</span><span style="color: #E06C75">SimpleListItem</span><span style="color: #ABB2BF">)</span></span></code></pre>
</code></pre><p>注意我们之前说的上一条原则，这里如果我们 connect 的是 List 这个组件，那么 <code>selectedItem</code> 改变的时候整个组件以及几百个子组件都会更新，这显然不是我们想要的。所以我们需要 connect 单独的每一个子组件。</p><p>但是如果像上面的代码一样直接把 <code>selectedItem</code> 的值传入，所有的子组件可能还是会更新一遍，因为 props 可能从 <code>{ selectedItem: 100 }</code> 变成了 <code>{ selectedItem: 200 }</code>，而我们实际上只需要根据 id 来检查当前的是否被选中，因此我们最好转化为：</p><pre><code class=language-js><pre class=shiki style="background-color: #282c34"><code><span class=line><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ListItem</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">connect</span><span style="color: #ABB2BF">(</span></span>
<span class=line><span style="color: #ABB2BF">  ({ </span><span style="color: #E06C75; font-style: italic">selectedItem</span><span style="color: #ABB2BF"> }, { </span><span style="color: #E06C75; font-style: italic">itemId</span><span style="color: #ABB2BF"> }) </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> ({ </span><span style="color: #E06C75">isSelected</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">selectedItem</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">itemId</span><span style="color: #ABB2BF"> })</span></span>
<span class=line><span style="color: #ABB2BF">)(</span><span style="color: #E06C75">SimpleListItem</span><span style="color: #ABB2BF">);</span></span></code></pre>
</code></pre><p>这样，每当 <code>selectedItem</code> 的值改变时，只有两个 ListItem 会被重新渲染。</p><h3 id=扁平化的数据结构>扁平化的数据结构</h3><p>这一点其实在<a href=https://redux.js.org/docs/recipes/reducers/NormalizingStateShape.html> Redux 文档</a>中有比较详细的说明。</p><h4 id=ref>ref</h4><ul><li><p><a href=https://redux.js.org/ >https://redux.js.org/</a></p></li><li><p><a href=https://reactrocket.com/post/react-redux-optimization/ >https://reactrocket.com/post/react-redux-optimization/</a></p></li></ul></div><div class=footer><hr><div class=footer-link><a href=/archive><i class="fa fa-archive" aria-hidden=true></i></a><a target=_blank href=https://twitter.com/chow_won><i class="fa fa-twitter" aria-hidden=true></i></a> <a target=_blank href=https://github.com/zoubingwu><i class="fa fa-github" aria-hidden=true></i></a> <a target=_blank href=mailto:zoubingwu@gmail.com><i class="fa fa-envelope" aria-hidden=true></i></a></div>© 2016-2023 zoubingwu. All rights reserved.</div></div></body></html>